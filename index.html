<!DOCTYPE html>
<html lang="zh-tw">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="這是一個紀錄自己成長的地方">
<meta property="og:type" content="website">
<meta property="og:title" content="Jeff的隨手筆記">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Jeff的隨手筆記">
<meta property="og:description" content="這是一個紀錄自己成長的地方">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Jeff">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-tw'
  };
</script>

  <title>Jeff的隨手筆記</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jeff的隨手筆記</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">學習當一個前端工程師</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Jeff">
      <meta itemprop="description" content="這是一個紀錄自己成長的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff的隨手筆記">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day27/" class="post-title-link" itemprop="url">『新手日記』Day-27 用官方文件開始學習React</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-12-30 15:38:42 / Modified: 16:01:19" itemprop="dateCreated datePublished" datetime="2022-12-30T15:38:42+08:00">2022-12-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">新手日記系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="『新手日記』Day-27-用官方文件開始學習React"><a href="#『新手日記』Day-27-用官方文件開始學習React" class="headerlink" title="『新手日記』Day-27 用官方文件開始學習React"></a><strong>『新手日記』Day-27 用官方文件開始學習React</strong></h1><p><img src="https://miro.medium.com/max/1400/1*UKcpy_AQVd4HmC7J0GRGfA.jpeg" alt="https://miro.medium.com/max/1400/1*UKcpy_AQVd4HmC7J0GRGfA.jpeg"></p>
<p>要準備進入學期三了，React是整個學期最重要的一個環節，因此到開學前都會放在React的學習。</p>
<p>所以新手日記系列就先停在27天吧，雖然因為身體因素導致沒有完成連續30天的類鐵人賽，但這段過程真的讓我收穫滿滿，雖然到後期有點亂掉但我相信這是我之後要挑戰鐵人賽的一次很好的經驗。</p>
<p>學習教材：</p>
<p><a target="_blank" rel="noopener" href="https://beta.reactjs.org/">官方文件</a></p>
<p>助教 PJ **的<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/users/20103315/ironman">鐵人賽</a>**及<a target="_blank" rel="noopener" href="https://pjchender.dev/">部落格</a></p>
<h1 id="React-是什麼？"><a href="#React-是什麼？" class="headerlink" title="React 是什麼？"></a><strong>React 是什麼？</strong></h1><p>進入<a target="_blank" rel="noopener" href="https://reactjs.org/">React的官網</a>就可以看到一行斗大的字：</p>
<h1 id="React：A-JavaScript-library-for-building-user-interfaces"><a href="#React：A-JavaScript-library-for-building-user-interfaces" class="headerlink" title="React：A JavaScript library for building user interfaces"></a>React：A JavaScript library for building user interfaces</h1><p>啥！！！React不是前端3大框架嗎？怎麼變成 library了。趕快去問我的好朋友Google小姐。</p>
<p>先跳出來的是好朋友<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Introduction#react">MDN</a>，他說：</p>
<h1 id="Technically-React-itself-is-not-a-framework-it’s-a-library-for-rendering-UI-components"><a href="#Technically-React-itself-is-not-a-framework-it’s-a-library-for-rendering-UI-components" class="headerlink" title="Technically, React itself is not a framework; it’s a library for rendering UI components."></a>Technically, React itself is not a framework; it’s a library for rendering UI components.</h1><p>不負責任翻譯：從技術上來說，React不是一個框架;他是一個渲染UI元件的函式庫。</p>
<p>那為什麼我們會說它是一個框架？</p>
<p>MDN有補充說明：</p>
<p><em><strong>由於 React 與 ReactDOM 通常會搭在一起用，React 在通俗上會被理解為 JavaScript 框架。</strong></em></p>
<p>那又有疑惑了，到底這兩個差在哪裡？有找到一篇ＡＣ助教粉粉學姊的文章(頭貼用一樣的我就當你是了)，大家可以點進去了解。</p>
<p>****<a target="_blank" rel="noopener" href="https://pink-learn-frontend.medium.com/%E5%89%8D%E7%AB%AF%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98-framework-%E6%A1%86%E6%9E%B6-%E4%B9%8B%E6%96%BClibrary-%E5%87%BD%E5%BC%8F%E5%BA%AB-%E5%B0%B1%E5%83%8F%E6%98%AF%E9%87%8D%E8%A8%93%E8%AA%B2%E8%A1%A8app%E4%B9%8B%E6%96%BC%E9%87%8D%E8%A8%93%E8%AA%B2%E8%A1%A8-464c828eec63">MediumEdit description**<br>pink-learn-frontend.medium.com</a></p>
<p>大家都了解了，那就進入我們的官方文件學習吧</p>
<h1 id="Your-First-Component"><a href="#Your-First-Component" class="headerlink" title="Your First Component"></a><strong>Your First Component</strong></h1><blockquote>
<p>You will learn</p>
</blockquote>
<ul>
<li>What a component is</li>
<li>What role components play in a React application</li>
<li>How to write your first React component</li>
</ul>
<p>React 中的元件（component）是一個小而可重複使用的程式碼，每一個元件都必須從 <code>Component</code> 這個類別（class）而來，<em>component class</em> 就像是一個可以用來建立許多不同元件的工廠。</p>
<p>傳統上，在創建網頁時，Web 開發人員會標記他們的內容，然後通過添加一些 JavaScript 來添加互動。React 將互動性放在首位，同時仍然使用相同的技術：<strong>a React component is a JavaScript function that you can <em>sprinkle with markup</em>.（React 元件是一個 JavaScript 函數，您可以<em>在其中添加標記</em>。）</strong></p>
<p>在這個小案例我們分成3個步驟：</p>
<blockquote>
<p>步驟1:Export the component</p>
</blockquote>
<p><code>export default</code>前綴是標準的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/web/javascript/reference/statements/export">JavaScript 語法</a>（不特定於 React）。它使您可以在文件中標記主要功能，以便以後可以從其他文件中導入它。</p>
<blockquote>
<p>步驟2:Define the function</p>
</blockquote>
<p>使用<code>function Profile() &#123; &#125;</code>名稱定義一個 JavaScript 函數<code>Profile</code>。</p>
<p>這邊有一個重點：</p>
<h1 id="React-components-are-regular-JavaScript-functions-but-or-they-won’t-work"><a href="#React-components-are-regular-JavaScript-functions-but-or-they-won’t-work" class="headerlink" title="React components are regular JavaScript functions, but or they won’t work!"></a>React components are regular JavaScript functions, but or they won’t work!</h1><p>翻譯：React 元件是常規的 JavaScript 函數，但<strong>它們的名稱必須以大寫字母開頭，</strong>否則它們將不起作用！</p>
<blockquote>
<p>步驟3:Add markup</p>
</blockquote>
<p>我們可以使用<a target="_blank" rel="noopener" href="https://pjchender.dev/react/react-jsx/">JSX</a>的方式編寫</p>
<p>這邊也有一個重點：就像我們在寫JavaScript裡的return一樣，return後面的 markup如果是同一行就不必加（）但如果不在同一行就必須要加，否則都會被忽略！！！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//同一行</span><br><span class="line">return &lt;img src=&quot;&lt;https://i.imgur.com/MK3eW3As.jpg&gt;&quot; alt=&quot;Katherine Johnson&quot; /&gt;</span><br><span class="line">//不同行</span><br><span class="line">return (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;img src=&quot;&lt;https://i.imgur.com/MK3eW3As.jpg&gt;&quot; alt=&quot;Katherine Johnson&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>這樣我們就完成了第一個Component，接下來如果今天有兩個以上的Component的話，我們要如何撰寫呢？</p>
<h1 id="Importing-and-Exporting-Components"><a href="#Importing-and-Exporting-Components" class="headerlink" title="Importing and Exporting Components"></a><strong>Importing and Exporting Components</strong></h1><blockquote>
<p>You will learn</p>
</blockquote>
<ul>
<li>What a root component file is</li>
<li>How to import and export a component</li>
<li>When to use default and named imports and exports</li>
<li>How to import and export multiple components from one file</li>
<li>How to split components into multiple files</li>
</ul>
<p>這個案例我們要學習的是引用其他檔案的元件，步驟如下：</p>
<ol>
<li><strong>創建</strong>一個新的 JS 文件來放入組件。</li>
<li><strong>從該文件中導出</strong>您的函數組件（使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/export#using_the_default_export">默認</a>導出或<a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/export#using_named_exports">命名</a>導出）。</li>
<li><strong>將其導入</strong>您將使用該組件的文件中（使用相應的技術來導入<a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/import#importing_defaults">默認</a>或<a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/import#import_a_single_export_from_a_module">命名</a>導出）。</li>
</ol>
<h1 id="💡-You-may-encounter-files-that-leave-off-the-file-extension-like-so-import-Gallery-from-39-Gallery-39-Either-or-will-work-with-React-though-the-former-is-closer-to-how-work"><a href="#💡-You-may-encounter-files-that-leave-off-the-file-extension-like-so-import-Gallery-from-39-Gallery-39-Either-or-will-work-with-React-though-the-former-is-closer-to-how-work" class="headerlink" title="💡 You may encounter files that leave off the file extension like so:import Gallery from &#39;./Gallery&#39;;Either or will work with React, though the former is closer to how work."></a>💡 You may encounter files that leave off the file extension like so:<code>import Gallery from &#39;./Gallery&#39;;</code>Either or will work with React, though the former is closer to how work.</h1><p>使用 JavaScript 導出值有兩種主要途徑：<strong>default exports（</strong>默認導出）和<strong>named exports（</strong>命名導出）。</p>
<p><strong>一個文件只能有一個default exports，但它可以有任意多個 named exports。</strong></p>
<p><img src="https://miro.medium.com/max/1400/1*7fxtgg-alyeJHLtDmsv-hg.png" alt="https://miro.medium.com/max/1400/1*7fxtgg-alyeJHLtDmsv-hg.png"></p>
<p>下圖是當你今天是用什麼語法，你的<strong>export跟import就必須是相對應的，否則就會出現錯誤</strong></p>
<p><img src="https://miro.medium.com/max/1400/1*hp7LiqhgDAhlaFF6L1n2yg.png" alt="https://miro.medium.com/max/1400/1*hp7LiqhgDAhlaFF6L1n2yg.png"></p>
<p><strong>如果文件只導出一個組件，人們通常使用default exports（</strong>默認導出）<strong>，如果它導出多個組件和值，則使用named exports（</strong>命名導出）<strong>。</strong></p>
<p>參考資料：<br><a target="_blank" rel="noopener" href="https://beta.reactjs.org/learn/your-first-component">beta.reactjs.org</a><br><a target="_blank" rel="noopener" href="https://beta.reactjs.org/learn/importing-and-exporting-components">beta.reactjs.org</a><br><a target="_blank" rel="noopener" href="https://pjchender.dev/react/react-jsx/">pjchender.dev</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Jeff">
      <meta itemprop="description" content="這是一個紀錄自己成長的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff的隨手筆記">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day26/" class="post-title-link" itemprop="url">『新手日記』Day-26 同步非同步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-12-30 15:37:42 / Modified: 16:00:38" itemprop="dateCreated datePublished" datetime="2022-12-30T15:37:42+08:00">2022-12-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">新手日記系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="『新手日記』Day-26-同步非同步"><a href="#『新手日記』Day-26-同步非同步" class="headerlink" title="『新手日記』Day-26 同步非同步"></a><strong>『新手日記』Day-26 同步非同步</strong></h1><p><img src="https://miro.medium.com/max/1400/1*crk2WP5jfhZmh1JJQEA2Ow.jpeg" alt="https://miro.medium.com/max/1400/1*crk2WP5jfhZmh1JJQEA2Ow.jpeg"></p>
<p>居然是因為生病中斷連載，難過！！！</p>
<p>最早在ＡＣ有一堂課是要我們學習分析什麼是 event loop。 在那邊第一次對同步跟非同步有了一絲的印象，那時候的文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/168538cd537243a18f89ba1dcca8b16d">https://www.notion.so/168538cd537243a18f89ba1dcca8b16d#49f4a62c06c7401084b31fb0f07df83e</a></p>
<p>之後陸陸續續在課堂或文章內容裡都有提到這個概念，但好像真的沒有認真的統整過一次，剛好在最新的課程裡講了Callback、Promises、Async&#x2F;Await，又加上我第一次沒有聽懂決定再看一次，順便統整一次內容。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>我們都知道『JavaScript 是一種單線程(single threaded runtime)的程式語言』，因為作為瀏覽器的腳本(程式語言)，他負責處理頁面的互動以及Dom的操作，讓你可以在網頁中實現出複雜的功能。但JavaScript 只是程式語言，因此我們需要一個『執行環境（runtime）』所提供的東西，例如說 setTiemout、document 等等，而這個 runtime可以是瀏覽器或是我們最近在學的Node.js。</p>
<h1 id="blocking（阻塞）與non-blocking（非阻塞）"><a href="#blocking（阻塞）與non-blocking（非阻塞）" class="headerlink" title="blocking（阻塞）與non-blocking（非阻塞）"></a><strong>blocking（阻塞）與non-blocking（非阻塞）</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let queue = []</span><br><span class="line">for (let i = 0; i &lt; 9999; i++) &#123;</span><br><span class="line">  queue.push(&#123; key: i &#125;)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;hello world&#x27;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">queue.forEach((item) =&gt; &#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我們用這段程式碼來解釋什麼是 blocking，大家可以順便猜一下會consloe.log出來什麼。</p>
<p>雖然<code>setTimeout</code> 的時間間距設定為 0，乍看之下是「馬上執行」的意思。但因為<code>setTimeout</code> 是屬於非同步事件，因此還是會在其他原始碼運行完以後才執行。</p>
<p>執行流程如下圖：</p>
<p><img src="https://miro.medium.com/max/1400/1*sqbXQ54bn1nJdR2Kn2BhhQ.png" alt="https://miro.medium.com/max/1400/1*sqbXQ54bn1nJdR2Kn2BhhQ.png"></p>
<p>在執行<code>queue.forEach</code> 由於資料過於龐大程式就會停在<code>queue.forEach</code>，要等執行完畢以後，才會去執行<code>setTimeout</code>。換句話說，<code>queue.forEach</code>「阻擋」了後續指令的執行，這時候我們就說這是一個 blocking（<strong>阻塞</strong>），因為程式的執行會一直 block 在這裡，直到執行完畢值為止。</p>
<p>如果後續指令跟現在在執行的程式有關那就只好認了，但如果現在執行的事情跟後續執行的事情一點關係都沒時，那把時間都浪費在這真的會奢侈。要解決這個狀況那我們就會運用到 <strong>non-blocking（非阻塞）。</strong></p>
<p>用一個生活化的方式來解釋：去百貨公司美食街點餐，點完以後店家會給我一個呼叫器，等到餐點準備好的時候，呼叫器就會響，我就可以去店家領取餐點，而不用在原地傻傻地等。<strong>所以要解決這個問題我們就必須拿到那個『呼叫器』，而在 JavaScript 裡面，function 就很適合當作呼叫器！</strong>意思就是「當這個程序執行完畢時，請來執行這個 function，並且把結果傳進來」，而這個 <strong>function 又被稱作 callback function（回呼函式）</strong></p>
<p>這樣我們就可以“看似”一次執行多個程式碼了，但請記住他只是“看似”而已，JavaScript 只是擅長用非同步的方式在不同事情間「切換」，它的本質仍然是一次執行一件事 (single thread)。</p>
<h1 id="synchronous-x2F-asynchronous"><a href="#synchronous-x2F-asynchronous" class="headerlink" title="synchronous&#x2F;asynchronous"></a><strong>synchronous&#x2F;asynchronous</strong></h1><p>了解了什麼是blocking（阻塞）與non-blocking（非阻塞）後，其實你已經懂了synchronous(同步) 與 asynchronous(非同步)，為什麼這麼說呢？因為在<a target="_blank" rel="noopener" href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/">Node.js 的官方文件</a>是這麼說的：</p>
<blockquote>
<p>Blocking methods execute synchronously and non-blocking methods execute asynchronously.</p>
<p><em>阻塞的方法會同步地（synchronously）執行，而非阻塞的方法會非同步地（asynchronously）執行</em></p>
</blockquote>
<p>但我相信還是會有很多人跟我一樣，同步不就是同時進行嗎？為什麼我卻只能一次執行一件事。</p>
<p>這就要提到中文翻譯的問題了，但我英文很差這邊就用另一個方式跟大家解釋：</p>
<h1 id="synchronous-同步"><a href="#synchronous-同步" class="headerlink" title="synchronous(同步)"></a><strong>synchronous(同步)</strong></h1><p>Synchronous：餐廳老闆自己從帶位、點餐、煮菜等，一條龍完成所有作業，在完成一組客人後，才能接待下一位客人。</p>
<p><img src="https://miro.medium.com/max/1400/1*-6eUIGF8QthDjcEBQuWxVQ.png" alt="https://miro.medium.com/max/1400/1*-6eUIGF8QthDjcEBQuWxVQ.png"></p>
<p>在JavaScript大部分功能都是同步的，而同步的定義是指：程式碼的執行順序，依照由上而下執行，最後才輸出。</p>
<p>優點當然是很好閱讀，但缺點就是效率變很差</p>
<h1 id="asynchronous-非同步"><a href="#asynchronous-非同步" class="headerlink" title="asynchronous(非同步)"></a><strong>asynchronous(非同步)</strong></h1><p>Asynchronous：餐廳老闆請了不同的人負責各自專門的事情，服務生負責點餐、廚師負責煮飯。在固定的時間內，可以藉由大家的合作，處理多組客人。</p>
<p><img src="https://miro.medium.com/max/1400/1*1UFWMlbdZqNzmZXqSi8mjw.png" alt="https://miro.medium.com/max/1400/1*1UFWMlbdZqNzmZXqSi8mjw.png"></p>
<p>在這案例我們可以得知：</p>
<ul>
<li>非同步機制能加速餐廳運作，更高效率的處理事情！</li>
<li>但非同步的狀況下，不同客人在不同階段需要的服務是不同的，因此員工間可能會產生「等待」的過程。</li>
</ul>
<p>我們可以總結：所謂的「非同步處理」，可以說就是釐清各式各樣的「等待」流程，並且在因「等待」而複雜化的程式流程中，確保程式能正確運作。。</p>
<h1 id="非同步處理的演進"><a href="#非同步處理的演進" class="headerlink" title="非同步處理的演進"></a><strong>非同步處理的演進</strong></h1><p><img src="https://miro.medium.com/max/1400/1*2ZVcVNQNDxHw6RcaM20aMA.png" alt="https://miro.medium.com/max/1400/1*2ZVcVNQNDxHw6RcaM20aMA.png"></p>
<p>接下來我會用同一個案例來練習同步處理：</p>
<h1 id="虛擬碼"><a href="#虛擬碼" class="headerlink" title="虛擬碼"></a><strong>虛擬碼</strong></h1><p>實際開發過程裡，收到專案規格後不會馬上開始撰寫程式碼，而是會用虛擬碼(pseudocode) 來釐清程式的邏輯。</p>
<p><img src="https://miro.medium.com/max/1394/1*xZPXXJdhY1Zc6vEPNGzAPg.png" alt="https://miro.medium.com/max/1394/1*xZPXXJdhY1Zc6vEPNGzAPg.png"></p>
<p>專案目的：你需要為 2 位重要的客人安排一趟台北美食探索之旅，現在你手邊精選出 6 家優質餐廳，需要安排他們各自嘗試其中的 3 間餐廳，2 位客人分配到的餐廳沒有重覆。</p>
<p>先簡單拆解程式必要做的事情：</p>
<blockquote>
<p>設定資料並連線資料庫：</p>
</blockquote>
<ul>
<li>從資料庫取得資料</li>
<li>將資料放進資料庫裡</li>
</ul>
<blockquote>
<p>推薦餐廳的邏輯：</p>
</blockquote>
<ul>
<li>先建立使用者資料、找到使用者與餐廳的關聯，並生成結果。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 資料描述</span><br><span class="line">users =  [ user1, user2 ]</span><br><span class="line">restaurants = [ rest1, rest2, rest3, rest4, rest5, rest6 ]</span><br><span class="line">// 資料庫連線設定</span><br><span class="line">連接資料庫(&#x27;資料庫名稱&#x27;)</span><br><span class="line">等待資料庫連接成功(100)// Step 1.建立使用者資料</span><br><span class="line">function 對每一個user進行處理 (user) &#123;</span><br><span class="line">  創建使用者資料(user)</span><br><span class="line">  等待創建使用者資料完成(100)	// Step 2.建立使用者與餐廳關聯</span><br><span class="line">	function 對每個user與restaurant進行處理 (rest)&#123;</span><br><span class="line">	  對每個user建立相對應餐廳資料(rest, user)</span><br><span class="line">	  等待創建餐廳資料完成(100)</span><br><span class="line">	&#125;(rest of restaurants)</span><br><span class="line">&#125; (user of users)// Step 3. 程式終止</span><br><span class="line">等待所有使用者的餐廳資料創建都完成(100)</span><br></pre></td></tr></table></figure>

<ul>
<li>由於資料庫對這支 JavaScript 程式來說，是一個外部的 server，我們不確定是否資料庫會連接成功，因此必須<strong>等待</strong>資料庫回傳「連接成功」的確認信號後，才能繼續往下執行程式。</li>
<li>若忽略了這個「等待」就匆匆執行「塞資料」的程序的話，就會出現資料消失等不能理解的狀況。</li>
</ul>
<h1 id="callback"><a href="#callback" class="headerlink" title="callback"></a><strong>callback</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">db.once(&#x27;open&#x27;, () =&gt; &#123;</span><br><span class="line">  console.log(&quot;openData connected&quot;)</span><br><span class="line">  for (const [user_index, user] of users.entries()) &#123;</span><br><span class="line">    // 創建使用者資料(user): model.create</span><br><span class="line">    UserModel.create(user, (err, user) =&gt; &#123;</span><br><span class="line">      console.log(&quot;user created&quot;)</span><br><span class="line">      const userRestaurant = []</span><br><span class="line">      restaurants.forEach((restaurants, rest_index) =&gt; &#123;</span><br><span class="line">        if (rest_index &gt;= 3 * user_index &amp;&amp; rest_index &lt; 3 * (user_index + 1)) &#123;</span><br><span class="line">          restaurants.userId = user._id</span><br><span class="line">          userRestaurant.push(restaurants)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      // 對每個user建立相對應餐廳資料</span><br><span class="line">      RestaurantModel.create(restaurants, (err, user) =&gt; &#123;</span><br><span class="line">        // 等待所有使用者的餐廳資料創建完成</span><br><span class="line">        console.log(&#x27;所有使用者與餐廳資料創建完成&#x27;)</span><br><span class="line">        UserModel.find().count((err, count) =&gt; &#123;</span><br><span class="line">          if (count &gt;= users.length) &#123;</span><br><span class="line">            print.exit()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="for-const-user-index-user-of-users-entries"><a href="#for-const-user-index-user-of-users-entries" class="headerlink" title="for (const [user_index, user] of users.entries())"></a><strong><code>for (const [user_index, user] of users.entries())</code></strong></h1><p>首先，使用 <code>for</code>拿出使用者的資料，並對每個使用者進行處理。因為要拿到資料庫裡的key&#x2F;value pairs 我們使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/entries">entries</a> 取出 <code>user_index。</code></p>
<h1 id="UserModel-create-user-err-user-gt-…"><a href="#UserModel-create-user-err-user-gt-…" class="headerlink" title="UserModel.create(user, (err, user) =&gt; {…}"></a><strong><code>UserModel.create(user, (err, user) =&gt; &#123;…&#125;</code></strong></h1><p>接著，使用 mongoose 提供的 <a target="_blank" rel="noopener" href="https://mongoosejs.com/docs/api.html#model_Model.create">Model.create</a> 建立使用者資料，這裡是一個典型的非同步操作：</p>
<ul>
<li>若操作成功，資料庫就會回傳一個成功創建的 <code>user</code> 物件，也就是我們設定給 UserModel.create 的第一個參數</li>
<li>若成功取得 user 物件，就執行第二個參數中設定的 callback function，也就是 <code>(err, user)=&gt;&#123; &#125;)</code> 這段</li>
</ul>
<h1 id="restaurants-forEach-restaurants-rest-index-gt-…"><a href="#restaurants-forEach-restaurants-rest-index-gt-…" class="headerlink" title="restaurants.forEach((restaurants, rest_index) =&gt; {…}"></a><strong><code>restaurants.forEach((restaurants, rest_index) =&gt; &#123;…&#125;</code></strong></h1><p>用 <code>forEach</code> 取出 data 中 restaurants 資料（包含 restaurant, rest_index），下一步用條件式建立使用者與餐廳資料的關聯。</p>
<p>條件式建立後，每個 restaurant 會有一個 <code>userId</code> 的參數，與創建使用者時自動生成的 user._id 做 mapping，可以用 <code>restaurant.userId = user._id</code> 表示，建立使用者跟餐廳資料的關聯。</p>
<p><img src="https://miro.medium.com/max/1400/1*XLnZDvUhrFsBAenzltm2aw.png" alt="https://miro.medium.com/max/1400/1*XLnZDvUhrFsBAenzltm2aw.png"></p>
<p>接下來想要用 <code>RestaurantModel.create</code> 將餐廳資料一次性的塞進資料庫裡，需要先建立 <code>userRestaurant = []</code> ，並用 <code>userRestaurant.push(restaurant)</code> ，將匹配好的資料暫存到陣列中。</p>
<h1 id="RestaurantModel-create-restaurants-err-user-gt-…"><a href="#RestaurantModel-create-restaurants-err-user-gt-…" class="headerlink" title="RestaurantModel.create(restaurants, (err, user) =&gt; {…}"></a><strong><code>RestaurantModel.create(restaurants, (err, user) =&gt; &#123;…&#125;</code></strong></h1><p>程式終止的條件是：等待所有使用者的餐廳資料都建立完成。</p>
<p>在邏輯設計上，我們可以用 count 函式確認所有 users 與 restaurants 都成功創建完畢，來判定資料建立完成並結束執行程式。</p>
<p>此時可以用 node.js 提供的 <code>process.exit</code> 來終止程序。</p>
<h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a><strong>Promises</strong></h1><p>Promise 是一個物件建構子 (constructor)，使用時需要先從 Promise 物件產生物件實例 (instance)，再使用繼承特性的 instance 去包裝程式碼的 callback 流程。</p>
<h1 id="callback-hell"><a href="#callback-hell" class="headerlink" title="callback hell"></a><strong>callback hell</strong></h1><p><a target="_blank" rel="noopener" href="https://www.notion.so/168538cd537243a18f89ba1dcca8b16d">https://www.notion.so/168538cd537243a18f89ba1dcca8b16d#2dd5a20abbf743cbb92bbed9f103796e</a></p>
<h1 id="從-Callback-到-Promise"><a href="#從-Callback-到-Promise" class="headerlink" title="從 Callback 到 Promise"></a><strong>從 Callback 到 Promise</strong></h1><p><img src="https://miro.medium.com/max/1400/1*t9vJZA-tDQ-tXrXF6pUh4A.png" alt="https://miro.medium.com/max/1400/1*t9vJZA-tDQ-tXrXF6pUh4A.png"></p>
<p>從邏輯上來說，程式流程有 4 段：</p>
<ol>
<li>先創建 User 資料，也就是 for loop + UserModel.create 的段落</li>
<li>UserModel.create 執行成功後，略為整理資料，進行 User x Restaurant 的配對</li>
<li>再用 RestaurantModel.create 創建資料，</li>
<li>兩個資料都創建好以後，就印個 console.log 然後終止程式</li>
</ol>
<p>在 callback 的版本中，流程 3 包含在 2 的 callback 裡，然後 4 又包在 3 的 callback 裡。</p>
<p>至於在 Promise 版本裡，可以運用 then 的架構，把四段流程刻意拉出來，創造一種由上而下的閱讀體驗。</p>
<h1 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a><strong>async&#x2F;await</strong></h1><p>使用邏輯很簡單，如下圖示意：</p>
<p><img src="https://miro.medium.com/max/1400/0*ZBkFYwv8WSZvDmVE.png" alt="https://miro.medium.com/max/1400/0*ZBkFYwv8WSZvDmVE.png"></p>
<p>原本當同步與非同步邏輯混搭時，我們會需要用一堆 then 來控制先後順序，而在 async&#x2F;await 中，只要關鍵字放對了，就可以確保程式按照「視覺上由上而下的順序」來執行。例如上圖示意的 1～5。</p>
<p>使用時要把握三個原則：</p>
<p>1.要先確認有 Promise 物件實例，也就是已經定義好 resolve&#x2F;reject，才能使用 async&#x2F;await</p>
<p>2.在流程中正確設定關鍵字：</p>
<ul>
<li>把後續流程用一個 <code>async function</code> 包裝起來</li>
<li>設定好 <code>async function</code> 之後，在要運用非同步處理的地方加上 <code>await</code> 關鍵字</li>
</ul>
<p>3.注意 async&#x2F;await 和 then 不可以混搭使用</p>
<h2 id="流程架構"><a href="#流程架構" class="headerlink" title="流程架構"></a><strong>流程架構</strong></h2><p><img src="https://miro.medium.com/max/1400/0*ZP5aNyvd4YaOLES7.png" alt="https://miro.medium.com/max/1400/0*ZP5aNyvd4YaOLES7.png"></p>
<p>仍然會有雙層的結構，因此兩個層級各需要一個 <code>async</code> 關鍵字，而 <code>await</code> 後面接的都是 Promise 物件，也就是需要非同步處理的區塊。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Jeff">
      <meta itemprop="description" content="這是一個紀錄自己成長的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff的隨手筆記">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day25/" class="post-title-link" itemprop="url">『新手日記』Day-25 Promise的初次見面</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-12-30 15:36:42 / Modified: 15:59:59" itemprop="dateCreated datePublished" datetime="2022-12-30T15:36:42+08:00">2022-12-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">新手日記系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="『新手日記』Day-25-Promise的初次見面"><a href="#『新手日記』Day-25-Promise的初次見面" class="headerlink" title="『新手日記』Day-25 Promise的初次見面"></a><strong>『新手日記』Day-25 Promise的初次見面</strong></h1><p><img src="https://miro.medium.com/max/1400/1*Zq8YHXBcuEmkAkPVZeCU0Q.jpeg" alt="https://miro.medium.com/max/1400/1*Zq8YHXBcuEmkAkPVZeCU0Q.jpeg"></p>
<p>最近…真的會完蛋，早上ＭＬＢ晚上ＣＰＢＬ等到了11月還有世界杯…..該不該把電視砸了…</p>
<p>Promise 本身是用來改善 JavaScript 非同步的語法結構。JavaScript 是屬於同步的程式語言，因此『一次僅能做一件事情』，但遇到非同步的事件時，就會將非同步的事件移動到程式碼的最後方，等到所有的原始碼運行完以後才會執行非同步的事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;開始&#x27;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;非同步事件&#x27;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(&#x27;程式碼結束&#x27;);</span><br></pre></td></tr></table></figure>

<p>用這個例子就可以很好說明，相信有很多人新手會跟我一樣直覺反應因為setTimeout設定為0所以回直接執行，所以印出來的順序會是：開始 →非同步事件 →程式碼結束。</p>
<p>但結果卻是：</p>
<p><img src="https://miro.medium.com/max/1400/1*NTvMSUDVkQNL_n6lSH30yA.png" alt="https://miro.medium.com/max/1400/1*NTvMSUDVkQNL_n6lSH30yA.png"></p>
<p>雖然setTimeout 所定義的時間為 0，但因為是屬於非同步事件，因此還是會在其他原始碼運行完以後才執行。</p>
<p>在了解了非同步後，我們來認識一下：Promise</p>
<blockquote>
<p>Promise</p>
</blockquote>
<p>Promise 是一個物件建構子 (constructor)，使用時需要先從 Promise 物件產生物件實例 (instance)，再使用繼承特性的 instance 去包裝程式碼的 callback 流程。</p>
<p><img src="https://miro.medium.com/max/1400/0*mlt4DyzgcZRzy6Jh.png" alt="https://miro.medium.com/max/1400/0*mlt4DyzgcZRzy6Jh.png"></p>
<p>Promise 是用於進行流程控制的物件 (容器)，它具備了 callback 的優點，但透過 <code>.then()</code> 來標明流程，而 <code>.then()</code> 之間可以互相鏈結 (chaining)，把之前「一層包一層的 callback」，轉換成 <code>.then()</code> 的串接。</p>
<p>一個 <code>Promise</code> 物件處於以下幾種狀態：</p>
<ul>
<li><em>擱置（pending）</em>：初始狀態，不是 fulfilled 與 rejected。</li>
<li><em>實現（fulfilled）</em>：表示操作成功地完成。</li>
<li><em>拒絕（rejected）</em>：表示操作失敗了。</li>
</ul>
<p>而他可以使用的 methods 有以下：</p>
<p><code>[Promise.all](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise/all%3E)</code></p>
<p><code>[Promise.race](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)</code></p>
<p><code>[Promise.reject](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject)</code></p>
<p><code>[Promise.resolve](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve)</code></p>
<p>一個 <code>Promise</code> 物件透過 <code>new</code> 及其建構式建立。這個建構式接收一個叫作”執行器函式（executor function）“的引數。此函式接收兩個函式作為引數。第一個函式（<code>resolve）</code>在非同步作業成功完成時，以該作業之結果值被呼叫。第二個函式（<code>reject</code>）在作業失敗時，以失敗訊息，通常是一個 error object，被呼叫。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myFirstPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // 執行一些非同步作業，最終呼叫:</span><br><span class="line">  //</span><br><span class="line">  //   resolve(someValue); // 實現</span><br><span class="line">  // 或</span><br><span class="line">  //   reject(&quot;failure reason&quot;); // 拒絕</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise 建構函式 <strong>new 出的物件</strong>，則可以使用其中的原型方法（在 <code>prototype</code> 內），其中就包含 <code>then</code>、<code>catch</code>、<code>finally</code>，這些方法則必須在新產生的物件下才能呼叫。</p>
<p>透過 <code>new Promise()</code> 的方式建立 <code>p</code> 物件，此時 myFirstPromise 就能使用 Promise 的原型方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const myFirstPromise =new Promise();myFirstPromise.then();// Promise 回傳正確</span><br><span class="line">myFirstPromise.catch();// Promise 回傳失敗</span><br><span class="line">myFirstPromise.finally();// 非同步執行完畢（無論是否正確完成）</span><br></pre></td></tr></table></figure>

<p>上述解釋大部份都是由mdn翻譯而來，我們用另外一個作者所講解的方式相信各位會更了解：</p>
<h1 id="Promise-的意義"><a href="#Promise-的意義" class="headerlink" title="Promise 的意義"></a><strong>Promise 的意義</strong></h1><p>Promise，如字面的意思就代表 <strong>承諾</strong>。</p>
<h1 id="承諾的未來"><a href="#承諾的未來" class="headerlink" title="承諾的未來"></a><strong>承諾的未來</strong></h1><p>當你拿到一個 Promise 的時候，代表在未來中這個 Promise 可能會有幾種狀況發生</p>
<blockquote>
<p>承諾 被兌現 (fulfilled)</p>
</blockquote>
<ul>
<li>用 <code>resolve()</code> 來兌現</li>
</ul>
<blockquote>
<p>承諾 被打破 (rejected)</p>
</blockquote>
<ul>
<li>用 <code>reject()</code> 來表示失敗</li>
</ul>
<blockquote>
<p>承諾 一直沒有回應 (pending)</p>
</blockquote>
<ul>
<li>一直沒有回傳</li>
</ul>
<h1 id="也就是說，承諾代表的不見得是成功。"><a href="#也就是說，承諾代表的不見得是成功。" class="headerlink" title="也就是說，承諾代表的不見得是成功。"></a>也就是說，承諾代表的不見得是成功。</h1><h1 id="未來之後"><a href="#未來之後" class="headerlink" title="未來之後"></a><strong>未來之後</strong></h1><p>而根據這三種結果，我們接下來的動作會有所不同，如果：</p>
<blockquote>
<p>承諾被兌現 就 繼續做預定好的下一件事</p>
</blockquote>
<ul>
<li>使用 <code>.then()</code></li>
</ul>
<blockquote>
<p>承諾被打破 就 根據這個原因去做對應的動作</p>
</blockquote>
<ul>
<li>使用 <code>.catch()</code>，或是 <code>.then</code> 的第二個參數</li>
<li>承諾 一直都沒有回應 就 <strong>繼續等下去</strong></li>
</ul>
<p><img src="https://miro.medium.com/max/1400/1*YOOs9t4N__o4r3gY_Nl8tw.png" alt="https://miro.medium.com/max/1400/1*YOOs9t4N__o4r3gY_Nl8tw.png"></p>
<p>是不是很快就搞懂了。</p>
<p>💡 <strong>Promise Chain：</strong><code>.then</code>不論是非同步或者同步的程式都可以串接，而 <code>then</code> 會回傳一個 <code>Promise</code>。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/aszx87410/blog">github.com</a><br><a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10197427">ithelp.ithome.com.tw</a><br><a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10197529">ithelp.ithome.com.tw</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Jeff">
      <meta itemprop="description" content="這是一個紀錄自己成長的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff的隨手筆記">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day24/" class="post-title-link" itemprop="url">『新手日記』Day-24 JavaScript 的原型鍊</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-12-30 15:35:42 / Modified: 15:58:31" itemprop="dateCreated datePublished" datetime="2022-12-30T15:35:42+08:00">2022-12-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">新手日記系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="『新手日記』Day-24-JavaScript-的原型鍊"><a href="#『新手日記』Day-24-JavaScript-的原型鍊" class="headerlink" title="『新手日記』Day-24 JavaScript 的原型鍊"></a><strong>『新手日記』Day-24 JavaScript 的原型鍊</strong></h1><p><img src="https://miro.medium.com/max/1400/1*YG13dBl8LH3Ta47VeQ96yQ.png" alt="https://miro.medium.com/max/1400/1*YG13dBl8LH3Ta47VeQ96yQ.png"></p>
<p>聽說我們的富奸又要開始連載了，庫拉皮卡終於可以下船了～～</p>
<p>此篇文章是節錄<a target="_blank" rel="noopener" href="https://github.com/aszx87410/blog/issues/18">這篇文章</a>的內容所做的重點整理，如有興趣可以點進去閱讀原版資料。</p>
<blockquote>
<p>JavaScript的前世今生</p>
</blockquote>
<p>1994年，網景公司（Netscape）發布了Navigator瀏覽器0.9版。但是，這個版本的瀏覽器只能用來瀏覽，不具備與訪問者互動的能力。因此網景公司急需一種網頁腳本語言，使得瀏覽器可以與網頁互動而工程師<a target="_blank" rel="noopener" href="https://brendaneich.com/">Brendan Eich</a>負責開發這種新語言。</p>
<p>當時C++是最流行的語言，Java語言的1.0版即將於第二年推出，Brendan Eich無疑受到了影響，Javascript裡面所有的數據類型都是object。這時他遇到了一個難題，到底要不要設計”繼承”機制呢？因為一種簡易的腳本語言，是不需要有”繼承”機制，而且一旦有了，Javascript就是一種<strong>物件導向程式設計（OOP）</strong>了，增加了初學者的入門難度。但是，Javascript裡面都是object，必須有一種機制，將所有對象聯繫起來。所以，Brendan Eich最後還是設計了”繼承”。</p>
<blockquote>
<p>JavaScript 中的 class</p>
</blockquote>
<p>但同時他卻不打算引入class的概念，他考慮到C++和Java語言都使用new命令，生成instance。因此，他就把new命令引入了Javascript，用來從原型對像生成一個instance object。但是，Javascript沒有”class”，怎麼來表示prototype object呢？</p>
<p>這時，他想到C++和Java使用new命令時，都會調用”class”的構造函數（constructor）。他就做了一個簡化的設計，在Javascript語言中，new命令後面跟的不是class，而是構造函數。</p>
<p>舉例來說，現在有一個叫做DOG的構造函數，表示狗對象的原型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function DOG(name)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>對這個構造函數使用new，就會生成一個狗對象的instance。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dogA = new DOG(&#x27;大毛&#x27;);</span><br><span class="line">alert(dogA.name); // 大毛</span><br></pre></td></tr></table></figure>

<p>注意構造函數中的<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html">this關鍵字</a>，它就代表了新創建的prototype object。</p>
<blockquote>
<p>探究原理</p>
</blockquote>
<p>了解了JavaScript的前世今生後，我們來看看下面內容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.log = function () &#123;</span><br><span class="line">    console.log(this.name + &#x27;, age:&#x27; + this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var nick = new Person(&#x27;nick&#x27;, 18);</span><br><span class="line">var peter = new Person(&#x27;peter&#x27;, 20);</span><br><span class="line"></span><br><span class="line">console.log(nick.log === peter.log) // false</span><br></pre></td></tr></table></figure>

<p>name 跟 age 這兩個屬性，很明顯每一個 instance 都會不一樣的。但在 log 這個 method中其實每一個 instance 彼此之間可以共享的，雖然 nick 跟 peter 的 log 這個 function 是在做同一件事，但其實還是佔用了兩份空間，意思就是他們其實是兩個不同的 function。</p>
<p>如果我要兩個都是一樣那怎麼辦呢？我們可以把這個 function 抽出來，變成所有 Person 都可以共享的方法。這邊我們要用一個東西叫做<code>prototype</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.log = function () &#123;</span><br><span class="line">  console.log(this.name + &#x27;, age:&#x27; + this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var nick = new Person(&#x27;nick&#x27;, 18);</span><br><span class="line">var peter = new Person(&#x27;peter&#x27;, 20);</span><br><span class="line"></span><br><span class="line">console.log(nick.log === peter.log) // true</span><br><span class="line"></span><br><span class="line">nick.log(); // nick, age:18</span><br><span class="line">peter.log(); // peter, age:20</span><br></pre></td></tr></table></figure>

<p>看到這裡我就有一個疑問，呼叫<code>nick.log()</code>的時候，JavaScript 是怎麼找到這個 function 的？</p>
<p>因為 nick 這個 instance 本身並沒有 log 這個 function。但根據 JavaScript 的機制，nick 是 Person 的 instance，所以如果在 nick 本身找不到，它會試著從<code>Person.prototype</code>去找。所以nick 跟<code>Person.prototype</code> 應該會透過某種方式連接起來，而這個連接的方式，就是<code>__proto__</code>。（附註：比較好的方式是用<code>Object.getPrototypeOf()</code>，但這邊為了方便起見，還是使用比較常見的<code>__proto__</code>，更詳細的說明可參考：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">MDN: Object.prototype.proto</a>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.log = function () &#123;</span><br><span class="line">  console.log(this.name + &#x27;, age:&#x27; + this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var nick = new Person(&#x27;nick&#x27;, 18);</span><br><span class="line"></span><br><span class="line">console.log(nick.__proto__ === Person.prototype) // true</span><br></pre></td></tr></table></figure>

<p>nick 的<code>__proto__</code>會指向<code>Person.prototype</code>，所以在發現 nick 沒有 log 這個 method 的時候，JavaScript 就會試著透過<code>__proto__</code>找到<code>Person.prototype</code>，去看<code>Person.prototype</code>裡面有沒有 log 這個 method。</p>
<p>那假如<code>Person.prototype</code>還是沒有呢？那就繼續依照這個規則，去看<code>Person.prototype.__proto__</code>裡面有沒有 log 這個 method，就這樣一直不斷找下去。找到時候時候為止？找到某個東西的<code>__proto__</code>是 null 為止。意思就是這邊是最上層了。</p>
<p>而上面這一條透過<code>__proto__</code>不斷串起來的鍊，就叫做『原型鍊』。透過這一條原型鍊，就可以達成類似繼承的功能，可以呼叫自己 parent 的 method。</p>
<h2 id="名詞解釋："><a href="#名詞解釋：" class="headerlink" title="名詞解釋："></a><strong>名詞解釋：</strong></h2><blockquote>
<p>instanceof</p>
</blockquote>
<p><code>A instanceof B</code> 就是拿來判斷 A 是不是 B 的 instance</p>
<blockquote>
<p>constructor</p>
</blockquote>
<p>每一個 prototype 都會有一個叫做<code>constructor</code>的屬性，例如說<code>Person.prototype.constructor。</code>而這個屬性就會指向構造函數。<code>Person.prototype</code>的構造函數是什麼？當然就是<code>Person</code>囉。</p>
<blockquote>
<p>new</p>
</blockquote>
<p>有了原型鍊的概念之後，就不難理解<code>new</code>這個關鍵字背後會做的事情是什麼。</p>
<p>假設現在有一行程式碼是：<code>var nick = new Person(&#39;nick&#39;);</code>，那它有以下幾件事情要做：</p>
<ol>
<li>創出一個新的 object，我們叫它 O</li>
<li>把 O 的 <code>__proto__</code> 指向 Person 的 prototype，才能繼承原型鍊</li>
<li>拿 O 當作 context，呼叫 Person 這個建構函式</li>
<li>回傳 O</li>
</ol>
<p>把所有的資料都看過一遍，但感覺還要再看一次還有些地方不是很了解，大家有興趣可以到看一下原作者所寫的，他還有附上超多參考資料。<br><a target="_blank" rel="noopener" href="https://github.com/aszx87410/blog/issues/18">github.com</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Jeff">
      <meta itemprop="description" content="這是一個紀錄自己成長的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff的隨手筆記">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day23/" class="post-title-link" itemprop="url">『新手日記』Day-23 OOP物件導向程式設計</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-12-30 15:34:42 / Modified: 15:57:43" itemprop="dateCreated datePublished" datetime="2022-12-30T15:34:42+08:00">2022-12-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">新手日記系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="『新手日記』Day-23-OOP物件導向程式設計"><a href="#『新手日記』Day-23-OOP物件導向程式設計" class="headerlink" title="『新手日記』Day-23 OOP物件導向程式設計"></a><strong>『新手日記』Day-23 OOP物件導向程式設計</strong></h1><p><img src="https://miro.medium.com/max/1400/1*n2QyVDVEE7rDEMb9hWjLvg.jpeg" alt="https://miro.medium.com/max/1400/1*n2QyVDVEE7rDEMb9hWjLvg.jpeg"></p>
<p>人家上班族放國慶連假，我這個全職學習仔居然也學人家放假…這禮拜要加倍努力補回來。</p>
<p>在之前談到ODM（文件資料庫） 與 ORM（關聯式資料庫）時有提到，他們兩個<strong>都是讓開發者可以使用『物件導向』語法來操作的資料庫，那什麼是物件導向？</strong></p>
<h1 id="物件導向"><a href="#物件導向" class="headerlink" title="物件導向"></a><strong>物件導向</strong></h1><p>物件導向，完整名稱為Object-oriented programming（物件導向程式設計），使用物件的方式來模擬真實世界中的事物。ㄜ …有點抽象，換一總解釋。</p>
<p>假設我們有1隻手機要賣，我是不是要把他的名稱、價格、照片、特色等等的資料用一個物件的方式包起來，但假如我現在有100隻手機要賣，如果我照著一隻手機的寫法寫100次這樣太讓費時間了，因此我們會先統一為手機物件建立一個抽象化的簡單模型，然後在程式中使用此模型來快速建立結構一致的手機物件實例 (instance)。</p>
<p>簡單來說，他是將相關的變數（屬性）與函式（方法）結合成一個單位（也就是物件）</p>
<h1 id="OOP的四大pillar"><a href="#OOP的四大pillar" class="headerlink" title="OOP的四大pillar"></a><strong>OOP的四大pillar</strong></h1><p>OOP總共有四大支柱，分別是：</p>
<blockquote>
<p>Encapsulation（封裝）</p>
</blockquote>
<p>我們可以把許多屬性、方法包裝成一個物件使用</p>
<blockquote>
<p>Abstraction（抽象）</p>
</blockquote>
<p>將此物件的某些屬性與方法隱藏（hide）起來。</p>
<blockquote>
<p>Inheritance（繼承）</p>
</blockquote>
<p>是繼承者擁有某些屬性或是方法，我們很常在Event Delegation(事件指派)裡面使用到</p>
<p><a target="_blank" rel="noopener" href="https://medium.com/@cycivs07/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98-day-13-javascript-dom-event-15b668d937a">https:&#x2F;&#x2F;medium.com&#x2F;@cycivs07&#x2F;%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98-day-13-javascript-dom-event-15b668d937a</a></p>
<blockquote>
<p>Polymorphism（多型）</p>
</blockquote>
<p>使用相同名稱的方法，傳入不同的參數，會執行不同的指令。</p>
<p>越學越深才知道自己真的懂的很少，就以今天這個主題來說，簡單講可以像這樣舉例然後介紹，但往深一點去研究光一個繼承可能就要弄個老半天。</p>
<p>近期有在想是不是該結束這個類鐵人挑戰的系列，目前進入實作的複習感覺題材變少好多，還在猶豫的時候突然發現我的一個未看文章的資料夾</p>
<p><img src="https://miro.medium.com/max/800/1*-xlxPhAYlGBC1Rpdh-KuNA.png" alt="https://miro.medium.com/max/800/1*-xlxPhAYlGBC1Rpdh-KuNA.png"></p>
<p>恩找到方向了，接下來都會先把這些文章消化完並且找到分享的主題。</p>
<p>參考資料：<br><a target="_blank" rel="noopener" href="https://teagan-hsu.coderbridge.io/2021/01/05/javascript-oop-constructor-function-class/">teagan-hsu.coderbridge.io</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-TW/docs/Learn/JavaScript/Objects/Classes_in_JavaScript">https://developer.mozilla.org/zh-TW/docs/Learn/JavaScript/Objects/Classes_in_JavaScript</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Jeff">
      <meta itemprop="description" content="這是一個紀錄自己成長的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff的隨手筆記">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day22/" class="post-title-link" itemprop="url">『新手日記』Day-22 SASS以及BEM 命名規範</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-12-30 15:33:42 / Modified: 15:56:48" itemprop="dateCreated datePublished" datetime="2022-12-30T15:33:42+08:00">2022-12-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">新手日記系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="『新手日記』Day-22-SASS以及BEM-命名規範"><a href="#『新手日記』Day-22-SASS以及BEM-命名規範" class="headerlink" title="『新手日記』Day-22 SASS以及BEM 命名規範"></a><strong>『新手日記』Day-22 SASS以及BEM 命名規範</strong></h1><p><img src="https://miro.medium.com/max/1400/1*K6h1onQgngZ67uDMWeL7Dg.jpeg" alt="https://miro.medium.com/max/1400/1*K6h1onQgngZ67uDMWeL7Dg.jpeg"></p>
<p>這幾天突然看到一篇命名的文章，自己心裡想來解釋一下自己所了解的但突然發現自己說不出來，因此想說找個時間來複習一下，剛好ＡＣ講到命名是跟著SASS那就一起複習吧！</p>
<h1 id="CSS-的先天限制"><a href="#CSS-的先天限制" class="headerlink" title="CSS 的先天限制"></a><strong>CSS 的先天限制</strong></h1><p>CSS 的開發方式是「由上而下把所有的樣式設定逐條追加在 .css 文件裡」，而這種作法導致以下的問題：</p>
<blockquote>
<p>語法重複 (poor reusability)</p>
</blockquote>
<p>違反了程式設計裡著名的 DRY 原則 (Do not Repeat Yourself)。</p>
<blockquote>
<p>可維護性不佳</p>
</blockquote>
<p>重複的語法除了降低了開發速度，也降低了系統的可維護性。</p>
<blockquote>
<p>可讀性不佳 (poor readability)</p>
</blockquote>
<p>CSS 的本質是「樣式階層表 (stylesheet)」，而不是程式語言。</p>
<p>因此，它先天欠缺程式語言要素，你無法用 CSS 既有語法傳遞資訊。</p>
<h1 id="CSS-預處理器"><a href="#CSS-預處理器" class="headerlink" title="CSS 預處理器"></a><strong>CSS 預處理器</strong></h1><p>CSS 的先天限制的解決方案 — 『<strong>CSS 預處理器 (CSS Preprocessor)</strong> 』。</p>
<p>它本身是 CSS 語法的擴充，讓開發者能夠處理抽象邏輯，例如變數、模組、與繼承等等。目前流行的 CSS 預處理器有：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://sass-lang.com/">Sass</a>：最早誕生的預處理器 (2007~)，源於 Ruby 社群，發展成熟，普及度高，與 Less 相互影響，持續演進中。</li>
<li><a target="_blank" rel="noopener" href="http://lesscss.org/">Less</a>：稍晚於 Sass，強調兼容性並且更容易上手，也擁有自己的支持社群，例如著名的 Twitter Bootstrap 採用了 Less。</li>
<li><a target="_blank" rel="noopener" href="http://stylus-lang.com/">Stylus</a>：本質上和 Less&#x2F;Sass 類似，只是更為 Node.js 社群量身打造。</li>
</ul>
<p>在ＡＣ我學習到得是SCSS，疑這又是什麼？Sass在演變的歷史中分成了兩個分支：</p>
<ul>
<li>舊版語法稱之為 Sass indented syntax ，副檔名為 .sass 。</li>
<li>較新版的 Sass&#x2F;SCSS 是目前業界主流，SCSS 的全文是 Sassy CSS，副檔名為 .scss</li>
</ul>
<p>對於這段歷史可以參考<a target="_blank" rel="noopener" href="https://medium.com/@onepiece0328/%E5%95%8F%E9%81%8E%E4%B8%80%E7%99%BE%E6%AC%A1%E7%9A%84%E5%95%8F%E9%A1%8C%E4%B9%8B-sass-%E5%92%8C-scss-%E7%9A%84%E5%B7%AE%E5%88%A5-5bd7fd78942a">這篇文章</a></p>
<h1 id="SCSS基本語法"><a href="#SCSS基本語法" class="headerlink" title="SCSS基本語法"></a><strong>SCSS基本語法</strong></h1><blockquote>
<p>巢狀(Nesting)</p>
</blockquote>
<p>在 Sass 中，我們可以使用巢狀語法來編寫組合選擇符 (nested combinator) ，例如空白以及 &gt; + ~ ，以達到更好的可讀性。</p>
<p><img src="https://miro.medium.com/max/1400/1*kGiGCUiIoXXtOHoLvXqRJQ.png" alt="https://miro.medium.com/max/1400/1*kGiGCUiIoXXtOHoLvXqRJQ.png"></p>
<p>還有一個方便的功能是使用 &amp; 符號來代替父層</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  color: rgba(0, 0, 0, 1);</span><br><span class="line">  &amp;:hover&#123;</span><br><span class="line">      color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;編譯後</span><br><span class="line">=====&gt;.box&#123;</span><br><span class="line">  color: rgba(0, 0, 0, 1);</span><br><span class="line">&#125;</span><br><span class="line">.box:hover&#123;</span><br><span class="line">  color: rgba(255, 0, 0, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>變數 (variable) 與運算子 (operator) (關鍵字：$)</p>
</blockquote>
<p>變數可以使我們的 css 代碼具備更佳的可維護性與可讀性 — — Sass 使用冒號 : 進行變數的指派，並以分號 ; 作為結尾。此外，我們還可以針對數值進行各種常見的計算。</p>
<p><img src="https://miro.medium.com/max/1400/1*VrV86frUCBeV5Ia1QQLUFg.png" alt="https://miro.medium.com/max/1400/1*VrV86frUCBeV5Ia1QQLUFg.png"></p>
<p>$代表著宣告變數，變數可以用來儲存值，方便重複利用。(使用變數必須連同＄一起用)</p>
<blockquote>
<p>繼承與覆寫（關鍵字：％ @exten）</p>
</blockquote>
<p>繼承可以使多個類別都享有共同的屬性 — — Sass 使用 % 來宣告類別，並使用 @extend 來執行繼承。如果要覆寫屬性，則直接宣告即可。</p>
<p><img src="https://miro.medium.com/max/1400/1*w2iYCqJvDXKYkE1Z1fl5UQ.png" alt="https://miro.medium.com/max/1400/1*w2iYCqJvDXKYkE1Z1fl5UQ.png"></p>
<blockquote>
<p>混入(Mixins)（關鍵字：＠mixin ＠include）</p>
</blockquote>
<p>你可以將它視作一種更彈性的繼承 (inherit) 的實作方式。在 Sass 裡，我們使用 @mixin 進行宣告，並使用 @include 使用 mixin。</p>
<p><img src="https://miro.medium.com/max/1400/1*lspko4SwkdcPYMtzr_mFVw.png" alt="https://miro.medium.com/max/1400/1*lspko4SwkdcPYMtzr_mFVw.png"></p>
<blockquote>
<p>檔案模組化(關鍵字：@use)</p>
</blockquote>
<p>在 Sass 中，我們可以將檔案拆成多個，配合上妥善的命名，讓專案變得更容易管理。</p>
<p><img src="https://miro.medium.com/max/1400/1*HJD_K7wmNuaYbGJl-4_W3Q.png" alt="https://miro.medium.com/max/1400/1*HJD_K7wmNuaYbGJl-4_W3Q.png"></p>
<ul>
<li>開頭為底線 _ 的檔名在 Sass 中稱之為 partial，也就是一個低階的模組。</li>
<li>我們使用 @use 來引用 partial。請注意引用名稱不包含底線，也不包含副檔名。</li>
<li>模組有自己的命名空間 (namespace) ，使用模組中的變數時，必須給命名空間加上前綴，例如 base.$primary-color 。</li>
</ul>
<blockquote>
<p>引入、匯入(關鍵字：@Import)</p>
</blockquote>
<p>在檔案中加入其他SCSS或CSS檔案，最後編譯時會一併編譯。</p>
<p>假如我想在某個SCSS檔案裡面匯入head、main、footer等scss的檔案就可以使用下面這段程式碼</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;head.scss&quot;;</span><br><span class="line">@import &quot;main.scss&quot;;</span><br><span class="line">@import &quot;footer.scss&quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函式(Functions)</p>
</blockquote>
<p>使用 @function 的方式其實跟 JavaScript 沒甚麼兩樣，一樣會宣告 @function 並於需要時調用，可以帶入參數，需要使用@return才收的到產生的值。</p>
<p>但有個不同的觀念是，在 Sass 中使用 function 其最終目的會是產生一個經過計算的值，它無法動態的去改變任何結構，因為最終都會轉成 CSS 啊~~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$grid-width: 60px;</span><br><span class="line">$gutter-width: 10px;@function grid-width($n) &#123;</span><br><span class="line">  @return $n * $grid-width + ($n - 1) * $gutter-width;</span><br><span class="line">&#125;#sidebar &#123; width: grid-width(4);&#125;#main &#123;width: grid-width(8);&#125;// 轉成 CSS</span><br><span class="line">#sidebar &#123;</span><br><span class="line">  width: 270px;</span><br><span class="line">&#125;#main &#123;</span><br><span class="line">  width: 550px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://sass-lang.com/documentation/modules">Built-In Modules</a></p>
<blockquote>
<p>@each</p>
</blockquote>
<p>Sass 有兩種資料格式儲存: list 和 map。一般可以藉由預設 function 來取得單一值，例如: <code>nth($list，2)</code> 取得 $list 第二個索引的值。但如果今天是要跑全部的 list 或是全部的 map，就會需要 @each 這個指令</p>
<p><em><strong>遍歷 list</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@each $item in $list &#123;</span><br><span class="line">  //some rules or conditions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述語法的 $list 為要帶入的 list 資料，可以預先存成變數使用，也可以直接塞入一組 list。而 $item 則是遍歷整個 list 時每筆 item 的變數名，此名稱可以自己定義。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$list: (orange, purple, teal);</span><br><span class="line">@each $item in $list &#123;</span><br><span class="line">  .#&#123;$item&#125; &#123;</span><br><span class="line">    background: $item;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;// 也可以直接在 @each 中直接寫 list，兩者結果相同</span><br><span class="line">@each $item in orange, purple, teal &#123;</span><br><span class="line">  .#&#123;$item&#125; &#123;</span><br><span class="line">    background: $item;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;// 轉成 CSS</span><br><span class="line">.orange &#123;</span><br><span class="line">  background: orange;</span><br><span class="line">&#125;.purple &#123;</span><br><span class="line">  background: purple;</span><br><span class="line">&#125;.teal &#123;</span><br><span class="line">  background: teal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然可以遍歷整個 list 的資料，當然也可以搞定更複雜一點的二維 list，二維 list 的格式會像這樣:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$list: (puma, black, default), (sea-slug, blue, pointer), (egret, white, move)</span><br></pre></td></tr></table></figure>

<p>假設有三組 list，而每筆 list 本身又包含數個值，這樣二維 list 就會成立，因此我們可以想像成是 @each 總共會遍歷三次，而且每次的遍歷都會需要三個變數來塞值，因此就會寫成這樣:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 這邊以直接寫入 list 示範，變數會依序對應每組 list 的值</span><br><span class="line">@each $animal, $color, $cursor in (puma, black, default),</span><br><span class="line">                                  (sea-slug, blue, pointer),</span><br><span class="line">                                  (egret, white, move) &#123;</span><br><span class="line">  .#&#123;$animal&#125;-icon &#123;</span><br><span class="line">    background-image: url(&#x27;/images/#&#123;$animal&#125;.png&#x27;);</span><br><span class="line">    border: 2px solid $color;</span><br><span class="line">    cursor: $cursor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;// 轉成 CSS</span><br><span class="line">.puma-icon &#123;</span><br><span class="line">  background-image: url(&quot;/images/puma.png&quot;);</span><br><span class="line">  border: 2px solid black;</span><br><span class="line">  cursor: default;</span><br><span class="line">&#125;.sea-slug-icon &#123;</span><br><span class="line">  background-image: url(&quot;/images/sea-slug.png&quot;);</span><br><span class="line">  border: 2px solid blue;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;.egret-icon &#123;</span><br><span class="line">  background-image: url(&quot;/images/egret.png&quot;);</span><br><span class="line">  border: 2px solid white;</span><br><span class="line">  cursor: move;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>遍歷 map</strong></em></p>
<p>遍歷 map 的方式會跟 list 有一點點不同，畢竟 list 是多個單一值組在一起，但 map 會是多個含有 key 跟 value 的集合。使用 @each 在 map 身上的話，等於是依序遍歷 key 與 value，因此 @each 的變數會有兩個，分別在遍歷時帶入 key 與 value。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) &#123;</span><br><span class="line">  #&#123;$header&#125; &#123;</span><br><span class="line">    font-size: $size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;// 轉成 CSS</span><br><span class="line">h1 &#123;</span><br><span class="line">  font-size: 2em;</span><br><span class="line">&#125;h2 &#123;</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">&#125;h3 &#123;</span><br><span class="line">  font-size: 1.2em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="BEM-命名規範"><a href="#BEM-命名規範" class="headerlink" title="BEM 命名規範"></a><strong>BEM 命名規範</strong></h1><p>BEM由Yandex團隊提出來的一種創新命名Class名稱的設計模式。</p>
<p>BEM的意思是區塊（Block）、元素（Element）、修飾符（Modifier），它們最大的優勢就是可以光瀏覽class名稱就能夠告訴開發者它們彼此間的依賴關係。</p>
<ul>
<li>：僅作為連字符使用，表示某個塊或者某個子元素的多單詞之間的連接記號。</li>
<li>__ ：雙底線用來連接塊和塊的子元素</li>
<li>_ ：單底線用來描述一個塊或者塊的子元素的一種狀態</li>
</ul>
<h2 id="區塊-Block"><a href="#區塊-Block" class="headerlink" title="區塊 (Block)"></a><strong>區塊 (Block)</strong></h2><p>我們在設計網站時，一定會設計幾個區塊(Block)出來，如下圖裡面有Logo block、search block、menu block等等，這時候我們就會用class命名他們區塊對應的語意</p>
<p><img src="https://miro.medium.com/max/1400/1*bE_jIwS5MKId123ww7P0lQ.png" alt="https://miro.medium.com/max/1400/1*bE_jIwS5MKId123ww7P0lQ.png"></p>
<h2 id="元素-Element"><a href="#元素-Element" class="headerlink" title="元素 (Element)"></a><strong>元素 (Element)</strong></h2><p>我們由menu block來舉例，看到下圖選單內有四個元素，如果這些元素設定是會綁定在這個區塊上時，就可以在區塊的class後面加上雙底線__來辨識他是該區塊底下的元素，Class就會設計為.menu__item{}。PS：除了HTML tag外，如果是一個CSS組件也可把它視為元素 (Element) 。</p>
<p><img src="https://miro.medium.com/max/1310/1*Ua8o7LxN6Gnqy7HaKqeFfQ.png" alt="https://miro.medium.com/max/1310/1*Ua8o7LxN6Gnqy7HaKqeFfQ.png"></p>
<h2 id="修飾符（Modifier）"><a href="#修飾符（Modifier）" class="headerlink" title="修飾符（Modifier）"></a><strong>修飾符（Modifier）</strong></h2><p>用於定義 Block 或 Element 的外觀、狀態或類型，修飾符本質上類似於 HTML 屬性。</p>
<p>以下圖舉例：</p>
<p>修飾符可以在運行時更改（例如： DOM 事件的反應），因為javascript會動態加入class為.menu__item — active，因為這個原因，我們可以很容易判斷這個class是屬於元素還是修飾符的設定，只要看class最後面是雙中線 — 還是雙下底線__就知道他是屬於哪一種了。</p>
<p><img src="https://miro.medium.com/max/1400/1*nm0jRv64oCreUMVQKaiSag.png" alt="https://miro.medium.com/max/1400/1*nm0jRv64oCreUMVQKaiSag.png"></p>
<h1 id="BEM-命名法的好處"><a href="#BEM-命名法的好處" class="headerlink" title="BEM 命名法的好處"></a><strong>BEM 命名法的好處</strong></h1><p>BEM的關鍵是，可以獲得更多的描述和更加清晰的結構，從其名字可以知道某個標記的含義。於是，通過查看HTML 代碼中的class 屬性，就能知道元素之間的關聯。</p>
<p>常規的命名法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;article&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;body&quot;&gt;</span><br><span class="line">        &lt;button class=&quot;button-primary&quot;&gt;&lt;/button&gt;</span><br><span class="line">        &lt;button class=&quot;button-success&quot;&gt;&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>這種寫法從DOM 結構和類命名上可以了解每個元素的意義，但無法明確其真實的層級關係。在css 定義時，也必須依靠層級選擇器來限定約束作用域，以避免跨組件的樣式污染。</li>
</ul>
<p>使用了BEM 命名方法的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;article&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;article__body&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;tag&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;button class=&quot;article__button--primary&quot;&gt;&lt;/button&gt;</span><br><span class="line">        &lt;button class=&quot;article__button--success&quot;&gt;&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>通過BEM 命名方式，模塊層級關係簡單清晰，而且css 書寫上也不必作過多的層級選擇。</li>
</ul>
<p>又加上SCSS的巢狀特性以及＆可以連接之前父層的class後，非常適合我們使用。</p>
<p>在還沒接觸SCSS時，每次看自己的CSS總是覺得非常的凌亂，當自己想修改什麼東西時只能依靠註解來找到，命名更是我這個英文很差的人一個痛苦，會的單字已經不多了，還要想這些相近意思的名字。但學習到這個之後真的解決了很多的麻煩，雖然新寫法還需要熟悉，但我相信他會是我的最佳幫手！</p>
<p>參考資料：</p>
<p><a target="_blank" rel="noopener" href="https://en.bem.info/methodology/key-concepts/">https://en.bem.info/methodology/key-concepts/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Jeff">
      <meta itemprop="description" content="這是一個紀錄自己成長的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff的隨手筆記">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day21/" class="post-title-link" itemprop="url">『新手日記』Day-21 Handlebars是什麼？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-12-30 15:32:42 / Modified: 16:23:50" itemprop="dateCreated datePublished" datetime="2022-12-30T15:32:42+08:00">2022-12-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">新手日記系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="『新手日記』Day-21-Handlebars是什麼？"><a href="#『新手日記』Day-21-Handlebars是什麼？" class="headerlink" title="『新手日記』Day-21 Handlebars是什麼？"></a><strong>『新手日記』Day-21 Handlebars是什麼？</strong></h1><p><img src="https://miro.medium.com/max/1280/1*nbuabEZ9m12brsZbdp5d1w.jpeg" alt="https://miro.medium.com/max/1280/1*nbuabEZ9m12brsZbdp5d1w.jpeg"></p>
<p>最近有一個習慣，再搭配照片時，習慣用今天的主題下去找。結果今天出來的圖片都是腳踏車的把手，好奇去查了一下English ，原來handlebars會被翻譯成車把啊….</p>
<p><img src="https://miro.medium.com/max/1400/1*IMrPqyi7RwtNBRM4FindEg.png" alt="https://miro.medium.com/max/1400/1*IMrPqyi7RwtNBRM4FindEg.png"></p>
<p>之前學習前端的時候就有碰到使用handlebars，沒想到在後端學習還會遇到，想說那來整理一下，因為自己對於handlebars說實在並沒有太過熟悉。</p>
<h1 id="Template-Engine"><a href="#Template-Engine" class="headerlink" title="Template Engine"></a><strong>Template Engine</strong></h1><p>Template Engine『樣板引擎』，或譯成「模板引擎」，是一個網路開發者用來產生前端網頁的工具。Template Engine <strong>會把帶有 HTML 內容的「樣板檔案」 (template files) 轉換成真正的 HTML 檔案再回應到瀏覽器上</strong>。</p>
<p><img src="https://miro.medium.com/max/1400/1*ZmHbk6b6-3UKeoIgRbgyUg.png" alt="https://miro.medium.com/max/1400/1*ZmHbk6b6-3UKeoIgRbgyUg.png"></p>
<p>他有什麼用呢？大家去瀏覽網頁時應該都會碰過某些網站整個網站的樣式很接近吧，我們來看一下ＡＣ舉例的Line Today:</p>
<p><img src="https://miro.medium.com/max/1400/1*B_zDFJ_tH8LAw6hgzj2uHA.png" alt="https://miro.medium.com/max/1400/1*B_zDFJ_tH8LAw6hgzj2uHA.png"></p>
<p><img src="https://miro.medium.com/max/1400/1*SsEQGLBNO0i94vxvIxamBw.png" alt="https://miro.medium.com/max/1400/1*SsEQGLBNO0i94vxvIxamBw.png"></p>
<p>看到上面兩張圖片，會發現基本上畫面並沒有改變太多，主要只有內容會因為我選的主題不同而跑出相對應的新聞。</p>
<p>這就必須討論到 layout(佈局) 跟 partial template(局部樣板)</p>
<p>layout(佈局):<strong>在同一個網站內，幾乎每一個頁面都會套用的版型，就稱作佈局。如同下方黃色部份：</strong></p>
<p><img src="https://miro.medium.com/max/1352/1*Q16b6FoDXa19CeIm4L03fA.png" alt="https://miro.medium.com/max/1352/1*Q16b6FoDXa19CeIm4L03fA.png"></p>
<p>partial template(局部樣板)：</p>
<p>如同上方藍色部分，針對該頁面給予相對應的內容。</p>
<h1 id="handlebars"><a href="#handlebars" class="headerlink" title="handlebars"></a><strong>handlebars</strong></h1><p>世界上在Node.js上可以使用的 Template Engine有非常多，如：<a target="_blank" rel="noopener" href="https://github.com/jadejs/jade"><code>Jade</code></a>、<a target="_blank" rel="noopener" href="https://github.com/kirbysayshi/vash"><code>Vash</code></a>、<a target="_blank" rel="noopener" href="https://github.com/tj/ejs"><code>EJS</code></a>、<a target="_blank" rel="noopener" href="https://github.com/janl/mustache.js"><code>Mustache</code></a>、<a target="_blank" rel="noopener" href="https://github.com/linkedin/dustjs"><code>Dust.js</code></a>、<a target="_blank" rel="noopener" href="https://github.com/mozilla/nunjucks"><code>Nunjucks</code></a>、<a target="_blank" rel="noopener" href="https://github.com/wycats/handlebars.js"><code>Handlebars</code></a>、<a target="_blank" rel="noopener" href="https://github.com/soywiz/atpl.js"><code>atpl</code></a>、<a target="_blank" rel="noopener" href="https://href.li/?https://github.com/tj/haml.js"><code>haml</code></a></p>
<p>在ＡＣ我學習到的是 handlebars。</p>
<blockquote>
<p>『使用到 Template Engine 就不得不提到 MVC 架構 ，但因為篇幅的關係，這篇不會講到，之後會在專門整理出來給大家(喂～～你老高喔！！！)。』</p>
</blockquote>
<p>根據MVC架構中，View不只要呈現畫面<strong>外觀</strong>，更重要是能處理畫面渲染的<strong>邏輯</strong>。就像在瀏覽器提供了 DOM 讓我們能以 JavaScript 操作畫面，Express 也讓我們能在本地環境的伺服器中，藉由Template Engine來操作畫面。</p>
<p>首先第一步我們要先建立資料夾(安裝：npm i express-handlebars@版本號)： views 和 layouts 資料夾</p>
<p><img src="https://miro.medium.com/max/338/1*iCDnyAjwlLmLjwRhDQc2cQ.png" alt="https://miro.medium.com/max/338/1*iCDnyAjwlLmLjwRhDQc2cQ.png"></p>
<h2 id="views資料夾"><a href="#views資料夾" class="headerlink" title="views資料夾"></a><strong>views資料夾</strong></h2><p>根據不同內容建立不同的網頁內容，也就是剛提到的 partial template(局部樣板)</p>
<h2 id="layouts-資料夾"><a href="#layouts-資料夾" class="headerlink" title="layouts 資料夾"></a><strong>layouts 資料夾</strong></h2><p>放置會在每一個頁面中都出現的網頁樣式，也就是剛提到的 layout(佈局)</p>
<h1 id="如果你覺得副檔名叫-handlebars-太長，可以採用縮寫-hbs。使用長檔名或短檔名是個人習慣的差異，但有一些工程師強烈主張不採用縮寫"><a href="#如果你覺得副檔名叫-handlebars-太長，可以採用縮寫-hbs。使用長檔名或短檔名是個人習慣的差異，但有一些工程師強烈主張不採用縮寫" class="headerlink" title="如果你覺得副檔名叫 .handlebars 太長，可以採用縮寫 .hbs。使用長檔名或短檔名是個人習慣的差異，但有一些工程師強烈主張不採用縮寫"></a>如果你覺得副檔名叫 .handlebars 太長，可以採用縮寫 .hbs。使用長檔名或短檔名是個人習慣的差異，但有一些工程師強烈主張不採用縮寫</h1><h2 id="目前使用過的語法介紹："><a href="#目前使用過的語法介紹：" class="headerlink" title="目前使用過的語法介紹："></a><strong>目前使用過的語法介紹：</strong></h2><h2 id="each-迴圈"><a href="#each-迴圈" class="headerlink" title="#each 迴圈"></a><strong>#each 迴圈</strong></h2><p>是個常用功能，能讓我們在 view 使用迴圈，以大量產生結構類似的資料，像是清單、表格等。語法是用 #each 表示迴圈開始，用 &#x2F;each 表示結束。</p>
<p><img src="https://miro.medium.com/max/1400/1*IQu3AAFXAP1sWVBHj-TM9A.png" alt="https://miro.medium.com/max/1400/1*IQu3AAFXAP1sWVBHj-TM9A.png"></p>
<h2 id="if"><a href="#if" class="headerlink" title="#if"></a><strong>#if</strong></h2><p>能用在當某變數有值或存在時，渲染包含的內容。語法是用 #if 開始判斷條件，用 &#x2F;if 表示結束。</p>
<p><img src="https://miro.medium.com/max/1400/1*b590ILRWFQUMhW7KFfD5BQ.png" alt="https://miro.medium.com/max/1400/1*b590ILRWFQUMhW7KFfD5BQ.png"></p>
<h2 id="更多內容"><a href="#更多內容" class="headerlink" title="更多內容"></a><strong>更多內容</strong></h2><p>****<a target="_blank" rel="noopener" href="https://handlebarsjs.com/zh/guide/">介绍 | HandlebarsHandlebars 是一种简单的 模板语言 。 它使用模板和输入对象来生成 HTML 或其他文本格式。Handlebars 模板看起来像常规的文本，但是它带有嵌入式的 Handlebars 表达式 。 Handlebars 表达式是一个…**<br>handlebarsjs.com</a></p>
<h1 id="在Express-中使用Template-Engine"><a href="#在Express-中使用Template-Engine" class="headerlink" title="在Express 中使用Template Engine"></a><strong>在Express 中使用Template Engine</strong></h1><p><img src="https://miro.medium.com/max/1400/1*q7OHjFmF1tiNw2kfE55gyA.png" alt="https://miro.medium.com/max/1400/1*q7OHjFmF1tiNw2kfE55gyA.png"></p>
<blockquote>
<p>app.engine：</p>
</blockquote>
<p>透過這個方法來定義要使用的樣板引擎，其中</p>
<ul>
<li>第一個參數是這個樣板引擎的名稱</li>
<li>第二個參數是放入和此樣板引擎相關的設定。這裡設定了預設的佈局（default layout）需使用名為 <code>main</code> 的檔案。</li>
</ul>
<blockquote>
<p>app.set：</p>
</blockquote>
<p>透過這個方法告訴 Express 說要設定的 <code>view engine</code> 是 <code>handlebars</code>。</p>
<p>以上都是 Express 的固定使用語法格式。</p>
<p>簡單的把一些學過的東西整理一下，雖然接下學期三不知道會不會用到，但至少整理好之後查看也比較方便。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Jeff">
      <meta itemprop="description" content="這是一個紀錄自己成長的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff的隨手筆記">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day20/" class="post-title-link" itemprop="url">『新手日記』Day-20 CRUD是什麼？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-12-30 15:31:42 / Modified: 15:54:31" itemprop="dateCreated datePublished" datetime="2022-12-30T15:31:42+08:00">2022-12-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">新手日記系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="『新手日記』Day-20-CRUD是什麼？"><a href="#『新手日記』Day-20-CRUD是什麼？" class="headerlink" title="『新手日記』Day-20 CRUD是什麼？"></a><strong>『新手日記』Day-20 CRUD是什麼？</strong></h1><p><img src="https://miro.medium.com/max/1400/1*zSh5v9qABH8qSl-CKYqOJw.jpeg" alt="https://miro.medium.com/max/1400/1*zSh5v9qABH8qSl-CKYqOJw.jpeg"></p>
<p>在還沒開始學習後端時就有看過這個詞，在進入正式學習前先來預習一下吧</p>
<p>昨天我們有提到：『<strong>RESTful 的設計以「資源」為中心</strong>，再搭配 HTTP method 的動詞，以及 CRUD 等資料操作』，昨天認識了<strong>RESTful跟</strong>HTTP method，今天來認識CRUD</p>
<h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a><strong>CRUD</strong></h1><p><em><strong>CRUD</strong></em> 是設計資料系統時很重要的基本技巧，在維基百科翻譯為「增刪改查」，分表代表了：</p>
<ul>
<li>Create (C)新增，建立資料，將定義好的欄位寫入對應的值</li>
<li>Read (R) 讀取，讀取資料，查詢資料的相關內容</li>
<li>Update (U) 更新，更新特定欄位的資料</li>
<li>Delete (D) 刪除，刪除資料</li>
</ul>
<p>四個動作合併稱之為 CRUD，通常在 SQL資料庫或API，做某一資源存取的時候會遇到。</p>
<p><img src="https://miro.medium.com/max/1328/1*-ZKdeOpGSINCpKJOuC-SAQ.png" alt="https://miro.medium.com/max/1328/1*-ZKdeOpGSINCpKJOuC-SAQ.png"></p>
<p>來自維基百科<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A2%9E%E5%88%AA%E6%9F%A5%E6%94%B9#cite_note-1">https://zh.wikipedia.org/wiki/%E5%A2%9E%E5%88%AA%E6%9F%A5%E6%94%B9#cite_note-1</a></p>
<h1 id="CRUD應用"><a href="#CRUD應用" class="headerlink" title="CRUD應用"></a><strong>CRUD應用</strong></h1><p>SQL(Structured Query Language)，一種資料庫查詢和程式設計語言，用於存取數據以及查詢、更新和管理關係資料庫系統。</p>
<p>但在實務上，當我們用 Express.js 開發應用程式時，會希望能直接用 JavaScript 操作資料庫，而不需要另外撰寫 SQL。因此開發出了『物件映射 (object mapping)』 的技術，用程式語言裡的『物件』來包裝資料庫的 SQL (structured query language)，讓開發者可以直接使用物件導向的方式操作資料庫。</p>
<p>依不同的資料庫類型，會分別使用不同的映射技術：</p>
<blockquote>
<p>針對文件資料庫 (document database) 的：ODM (Object Document Mapper)</p>
<p><em>針對關聯式資料庫 (relational database)的：ORM (Object Relational Mapping)</em></p>
</blockquote>
<p><strong>ODM 與 ORM 都是讓開發者可以使用物件導向語法來操作資料庫</strong>，同時也增加程式碼的易讀性與維護性，只是對應的類型不同。</p>
<p>透過ＡＣ的例子，我們在資料庫尋找一筆名為『買蘋果』的TodoList透過 ORM 的語法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Todo.find (&#123; name: &#x27;買蘋果&#x27;, done: &#123; false &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>若使用 SQL 的指令的話，會是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Todos WHERE name=&#x27;買蘋果&#x27; AND done=FALSE;</span><br></pre></td></tr></table></figure>

<p>身為懶人的我當然選擇第一個啊XD</p>
<p>這是一篇比較偏向預習的文章，除了看ＡＣ的教案外還有鐵人賽的資料，但幾乎所有的文章主要的部分還是要靠實作來練習，基於本人生了一場名字叫懶惰的病，實作的部分就不放上來，連假第一天就得了病，希望明天可以痊癒XDD</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Jeff">
      <meta itemprop="description" content="這是一個紀錄自己成長的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff的隨手筆記">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day19/" class="post-title-link" itemprop="url">『新手日記』Day-19 HTTP request</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-12-30 15:30:42 / Modified: 15:51:35" itemprop="dateCreated datePublished" datetime="2022-12-30T15:30:42+08:00">2022-12-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">新手日記系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="『新手日記』Day-19-HTTP-request"><a href="#『新手日記』Day-19-HTTP-request" class="headerlink" title="『新手日記』Day-19 HTTP request"></a><strong>『新手日記』Day-19 HTTP request</strong></h1><p><img src="https://miro.medium.com/max/1280/1*FWo4FgVFK2o9EyrPyIaxBQ.jpeg" alt="https://miro.medium.com/max/1280/1*FWo4FgVFK2o9EyrPyIaxBQ.jpeg"></p>
<p>疑~既然都404了那我是不是可以不用打了XDD</p>
<p>進入到後端的世界了，一進來就來一個熟悉又陌生的名詞『路由(route)』。</p>
<p>路由是在網路傳輸裡的一種技術，後來轉移到 web application 的領域。</p>
<p>在網路應用程式開發的領域，路由是指 URL 的處理程序，這組處理程序會把 HTTP 動詞、URL、和相關的程式碼連接起來(不要跟路由器搞錯喔！)。</p>
<p>我們會在路由系統裡，定義「收到什麼 HTTP request，就執行什麼動作」。</p>
<h1 id="HTTP-request"><a href="#HTTP-request" class="headerlink" title="HTTP request"></a><strong>HTTP request</strong></h1><p>老樣子ＭＤＮ先來：</p>
<h1 id="HTTP-defines-a-set-of-request-methods-to-indicate-the-desired-action-to-be-performed-for-a-given-resource"><a href="#HTTP-defines-a-set-of-request-methods-to-indicate-the-desired-action-to-be-performed-for-a-given-resource" class="headerlink" title="HTTP defines a set of request methods to indicate the desired action to be performed for a given resource."></a>HTTP defines a set of request methods to indicate the desired action to be performed for a given resource.</h1><p>當Web service使用Web API進行介面介接時，每一串我們設計的URL，就會是一個專屬的服務『窗口』，<strong>不同的Method就是對同一件事情做不同的操作</strong>。</p>
<p><img src="https://miro.medium.com/max/1384/1*-11QF9ytiajrYC0RJxu7Tg.png" alt="https://miro.medium.com/max/1384/1*-11QF9ytiajrYC0RJxu7Tg.png"></p>
<p>在HTTP協定中，定義了多種不同的method做為服務的請求方法，最常見的method 有五種：GET｜POST｜PUT｜PATCH｜DELETE。</p>
<p>GET：取得(想要的服務)的資料或是狀態。（safe &amp; idempotent）</p>
<p>POST：將數據發送到指定的端點以創建或更新資源</p>
<p>PUT：用於更新資源</p>
<p>PATCH：用於修改資源</p>
<p>DELETE：刪除由 URI 標識的資源</p>
<p>了解這些後，我們要來運用他們，在使用前我們需要在學習2個名詞API &amp; RESTful</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a><strong>API</strong></h1><p>API ：Application Programming Interface，譯為「應用程式介面」，也就是「應用程式對外開放的介面」。主要用途是讓開發者可以透過 API 去使用其他人撰寫的應用程式。</p>
<p>這邊有一段簡單解釋API的小影片</p>
<p>應該很淺顯易懂吧！就如同上所說API是一種介面，使用者可以透過 API 使用應用程式的功能，但不需要碰觸到程式的內部運作。舉一個現實的例子：Google Map API</p>
<p><img src="https://miro.medium.com/max/1400/1*kK5BLD3jYOSkGylLJtiXZA.png" alt="https://miro.medium.com/max/1400/1*kK5BLD3jYOSkGylLJtiXZA.png"></p>
<p>只要用指定的方式發出請求 (request)，將餐廳地址成功發送給 Google Map API，Google Map 就會回應 (response) 地圖資訊：</p>
<p><img src="https://miro.medium.com/max/1396/1*Bi0Mej9LoOjS5SkZwAW02g.png" alt="https://miro.medium.com/max/1396/1*Bi0Mej9LoOjS5SkZwAW02g.png"></p>
<h1 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a><strong>RESTful</strong></h1><p>REST，全名 Representational State Transfer( 表現層狀態轉移)，他是<strong>一種軟體架構的設計風格，不是一種標準或是規格</strong>，只有提供原則概念。</p>
<p>符合 REST 的設計風格的軟體架構就可以稱做是 RESTful，符合此規範設計的 API，稱為 RESTful API。</p>
<p>以剛剛 API 影片中的餐廳服務生為例，如果使用一般的 API 點菜，我要<strong>加點</strong>、<strong>查看已點菜色</strong>、<strong>修改已點菜色</strong>、<strong>取消已點菜色</strong>，都需要不同的服務生替我服務，RESTful API，就是讓這些動作，都可以由同一位服務生完成。</p>
<p>RESTful API 主要由三種元件組成：</p>
<p><img src="https://miro.medium.com/max/426/0*6jID-64m9PfN8yJI.png" alt="https://miro.medium.com/max/426/0*6jID-64m9PfN8yJI.png"></p>
<ol>
<li>Nouns 名詞：定義資源位置的 URL，每個資源在網路上都會有唯一的位置，就如每戶人家都有唯一的地址一樣。</li>
<li>Verbs 動詞：對資源要做的動作。</li>
<li>Content Types 資源呈現方式：API 資源可以以多種方式表現，最常用的是 JSON，較輕，也較好處理。</li>
</ol>
<p>一般的 API，可能會是這樣：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">獲得資料GET    /getData</span><br><span class="line">新增資料POST   /createData</span><br><span class="line">刪除資料DELETE /deleteData/1</span><br></pre></td></tr></table></figure>

<p>在引用各家 API 時，都需要詳讀 API 文件，理解所有設計命名規則後，才可使用。</p>
<p>若以 RESTful API 風格開發的話：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">獲得資料GET     /data</span><br><span class="line">新增資料POST    /data</span><br><span class="line">刪除資料DELETE  /data/1</span><br></pre></td></tr></table></figure>

<p>就是用一個唯一的 URL 定位資源，將動作藏在 HTTP 的 method 裡面。</p>
<p>簡單介紹了一下，大概還有80％還沒搞懂吧&gt;&lt;”程式語言真的是一個坑越讀越大洞永遠補不滿，難怪常會聽到學不動這個詞。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Jeff">
      <meta itemprop="description" content="這是一個紀錄自己成長的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff的隨手筆記">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/30/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97-2022-12-30-day18/" class="post-title-link" itemprop="url">『新手日記』Day-18 Closures（閉包）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-12-30 15:29:42 / Modified: 15:49:50" itemprop="dateCreated datePublished" datetime="2022-12-30T15:29:42+08:00">2022-12-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">新手日記系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="『新手日記』Day-18-Closures（閉包）"><a href="#『新手日記』Day-18-Closures（閉包）" class="headerlink" title="『新手日記』Day-18 Closures（閉包）"></a><strong>『新手日記』Day-18 Closures（閉包）</strong></h1><p><img src="https://miro.medium.com/max/1280/1*1meqNIGbPPX7C32ChWNSSQ.jpeg" alt="https://miro.medium.com/max/1280/1*1meqNIGbPPX7C32ChWNSSQ.jpeg"></p>
<p>終於進路閉包了，第一次看到時的完全看不懂，經過了幾天的加強其他觀念，慢慢的了解了他的意思</p>
<h1 id="MDN解釋"><a href="#MDN解釋" class="headerlink" title="MDN解釋"></a><strong>MDN解釋</strong></h1><h1 id="A-closure-is-the-combination-of-a-function-bundled-綑綁-together-enclosed-with-references-to-its-surrounding-周圍-state-the-lexical-environment-詞法環境-In-other-words-a-closure-gives-you-access-to-an-outer-function’s-scope-from-an-inner-function-In-JavaScript-closures-are-created-創建-every-time-a-function-is-created-at-function-creation-time-閉包（Closure）是函式以及該函式被宣告時所在的作用域環境（lexical-environment）的組合。"><a href="#A-closure-is-the-combination-of-a-function-bundled-綑綁-together-enclosed-with-references-to-its-surrounding-周圍-state-the-lexical-environment-詞法環境-In-other-words-a-closure-gives-you-access-to-an-outer-function’s-scope-from-an-inner-function-In-JavaScript-closures-are-created-創建-every-time-a-function-is-created-at-function-creation-time-閉包（Closure）是函式以及該函式被宣告時所在的作用域環境（lexical-environment）的組合。" class="headerlink" title="A closure is the combination of a function bundled(綑綁) together (enclosed) with references to its surrounding(周圍) state (the lexical environment(詞法環境)).In other words, a closure gives you access to an outer function’s scope from an inner function.In JavaScript, closures are created(創建) every time a function is created, at function creation time.閉包（Closure）是函式以及該函式被宣告時所在的作用域環境（lexical environment）的組合。"></a>A closure is the combination of a function bundled(綑綁) together (enclosed) with references to its surrounding(周圍) state (the lexical environment(詞法環境)).In other words, a closure gives you access to an outer function’s scope from an inner function.In JavaScript, closures are created(創建) every time a function is created, at function creation time.閉包（Closure）是函式以及該函式被宣告時所在的作用域環境（lexical environment）的組合。</h1><p>大家是否跟我一樣是懂非懂？我們看一下範例：</p>
<h1 id="閉包的目的"><a href="#閉包的目的" class="headerlink" title="閉包的目的"></a><strong>閉包的目的</strong></h1><p><img src="https://miro.medium.com/max/1400/1*AjFoTACJe2DAbqRut0TVHA.png" alt="https://miro.medium.com/max/1400/1*AjFoTACJe2DAbqRut0TVHA.png"></p>
<p>這個寫有一個缺點，任何人都可以去更改 counter這個變數，為了他不被污染我想到把他放進function裏面。</p>
<p><img src="https://miro.medium.com/max/1400/1*hCdA6pysBjd0wrDrU8B8MQ.png" alt="https://miro.medium.com/max/1400/1*hCdA6pysBjd0wrDrU8B8MQ.png"></p>
<p>很棒，程式一樣可以執行，但這樣卻變成我的counter永遠都是1，這並不是我想要的，那要怎麼改呢？我的想法是，一樣放在外面但最外面用function包起來</p>
<p><img src="https://miro.medium.com/max/1400/1*Zb7bg4CUXnJVoOHa2U4Rxg.png" alt="https://miro.medium.com/max/1400/1*Zb7bg4CUXnJVoOHa2U4Rxg.png"></p>
<p>這樣就完成了我的需求。這就是一個簡單的閉包設定，因此我們可以歸類一下閉包想解決的問題：</p>
<blockquote>
<p>1.變數資料存在於的 Local Scope 裡，讓外部環境無法直接存取，以確保動作安全。</p>
</blockquote>
<p>我們希望操控的變數宣告於一個 Local Scope 內，限制它的存取權。因此<strong>閉包的第一個要素：函數。</strong></p>
<blockquote>
<p>2.即使 Local 的執行環境結束，Local 環境內建立的資料還是能持續存活</p>
</blockquote>
<p><strong>先破題-閉包的第二個要素：Reference。到這邊時我有一個苦惱很久的問題：</strong></p>
<p><em><strong>let sellTicket &#x3D; getSellTicketClosure();sellTicket(‘OneJar’)</strong></em></p>
<p>為什麼可以執行?我原本的想法：<em><strong>getSellTicketClosure(sellTicket(‘OneJar’))</strong></em></p>
<p>這就要牽扯到了『Pass by value 還是 Pass by reference』</p>
<p>****<a target="_blank" rel="noopener" href="https://medium.com/@cycivs07/%E6%96%B0%E6%89%8B%E6%97%A5%E8%A8%98-day-17-pass-by-value-%E5%92%8C-pass-by-reference-cbce5ff90d04">『新手日記』Day-17 Pass by value 和 Pass by reference每天到網路上找一張適合的照片或是當天的心情的過程居然可以變得如此開心！**<br>medium.com</a></p>
<p>由於他是一個Object，從這篇文章我們可以知道，要從「行為」上面來判別到底是屬於哪一種。</p>
<p>因為我們並沒有對變數重新賦值，因此他是屬於<strong>Reference</strong></p>
<p>所以他在傳遞的是一個『位子』，我們換一個寫法相信大家就更好理解：</p>
<p><img src="https://miro.medium.com/max/1400/1*7UigTkxAXpGob_9TAqtSkQ.png" alt="https://miro.medium.com/max/1400/1*7UigTkxAXpGob_9TAqtSkQ.png"></p>
<p>這樣是不是更好理解了…吧</p>
<h2 id="這邊簡單總結一下："><a href="#這邊簡單總結一下：" class="headerlink" title="這邊簡單總結一下："></a><strong>這邊簡單總結一下：</strong></h2><h1 id="閉包-Closures-是一個能存取父作用域的函數，即使父作用域已經結束"><a href="#閉包-Closures-是一個能存取父作用域的函數，即使父作用域已經結束" class="headerlink" title="閉包 (Closures) 是一個能存取父作用域的函數，即使父作用域已經結束"></a><strong>閉包 (Closures) 是一個能存取父作用域的函數，即使父作用域已經結束</strong></h1><h1 id="Closures重點整理："><a href="#Closures重點整理：" class="headerlink" title="Closures重點整理："></a><strong>Closures重點整理：</strong></h1><h1 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h1><p><em><strong>Closures運用的技巧：</strong></em></p>
<p>1.函數對變數的 Local Scope 封裝。</p>
<p>2.內部函數對外層函數變數的引用。</p>
<p>3.回傳內部函數的物件，形成Closures。</p>
<p><em><strong>Closures實際上儲存的是對外層函數變數的引用 (References)。</strong></em></p>
<p><em><strong>每一個Closures中保存的都是一個獨立的環境，不同閉包間不互相干擾。</strong></em></p>
<p><em><strong>可以用立即函數的寫法來簡化語法。</strong></em></p>
<p>理解Closures時才發現，為什麼參考資料的作者要我先去讀Pass by value 和Pass by reference，這個沒先讀熟還真的沒辦法瞭解其運作原理，我自己在***let sellTicket &#x3D; getSellTicketClosure();sellTicket(‘OneJar’)***真的卡住不懂為什麼我可以用這個方式呼叫函式，在重新看完作者的文章跟自己的筆記後大概瞭解為什麼了，但應該是自己真的還沒有全盤瞭解吧，寫出來的文字並沒有辦法完整表達出原本的意思，有興趣了解的可以參考下面這篇文章，如果有寫錯的地方在請大家指正！！！</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a><strong>參考資料</strong></h1><p><a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10209465">ithelp.ithome.com.tw</a><br><a target="_blank" rel="noopener" href="https://www.fooish.com/javascript/function-closure.html">www.fooish.com</a><br><a target="_blank" rel="noopener" href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/">blog.techbridge.cc</a></p>
<p>書籍：0 陷阱！0 誤解！8 天重新認識 JavaScript！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jeff"
      src="/uploads/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Jeff</p>
  <div class="site-description" itemprop="description">這是一個紀錄自己成長的地方</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jeff0518" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jeff0518" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cycivs07@icloud.com" title="E-Mail → mailto:cycivs07@icloud.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeff</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
